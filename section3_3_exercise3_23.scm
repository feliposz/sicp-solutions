(define (make-deque)
  (let ((front-ptr '())
        (rear-ptr '()))
    
    ; Some abstractions for the items to make the structure more readable
    (define (make-item value prev next) (cons value (cons prev next)))
    (define item-value car)
    (define item-pointers cdr)
    (define item-prev cadr)
    (define item-next cddr)
    (define (item-set-prev! item pointer)
      (set-car! (item-pointers item) pointer))
    (define (item-set-next! item pointer)
      (set-cdr! (item-pointers item) pointer))

    (define (empty-deque?)
      (null? front-ptr))
    (define (front-deque)
      (if (empty-deque?)
          (error "Front of empty deque")
          (item-value front-ptr)))
    (define (rear-deque)
      (if (empty-deque?)
          (error "Front of empty deque")
          (item-value rear-ptr)))
    (define (front-insert-deque! value)      
      (let ((new (make-item value '() '())))
        (cond ((empty-deque?)
               (set! front-ptr new)
               (set! rear-ptr new))
              (else
               (item-set-next! new front-ptr)
               (item-set-prev! front-ptr new)
               (set! front-ptr new)))))
    (define (rear-insert-deque! value)
      (let ((new (make-item value '() '())))
        (cond ((empty-deque?)
               (set! front-ptr new)
               (set! rear-ptr new))
              (else
               (item-set-prev! new rear-ptr)
               (item-set-next! rear-ptr new)
               (set! rear-ptr new)))))
    (define (front-remove-deque!)
      (cond ((empty-deque?)
             (error "Remove of empty deque"))
            (else
             (set! front-ptr (item-next front-ptr))
             (if (null? front-ptr)
                 (set! rear-ptr '())
                 (item-set-prev! front-ptr '())))))
    (define (rear-remove-deque!)
      (cond ((empty-deque?)
             (error "Remove of empty deque"))
            (else
             (set! rear-ptr (item-prev rear-ptr))
             (if (null? rear-ptr)
                 (set! front-ptr '())
                 (item-set-next! rear-ptr '())))))
    (define (print-deque)
      (define (print-loop element)
        (cond ((null? element)
               (newline))
              (else
               (display (item-value element))
               (display " ")
               (print-loop (item-next element)))))
      (display "Deque: ")
      (print-loop front-ptr))
    (define (dispatch m)
      (cond ((eq? m 'empty-deque?) empty-deque?)
            ((eq? m 'front-deque) front-deque)
            ((eq? m 'rear-deque) rear-deque)
            ((eq? m 'front-insert-deque!) front-insert-deque!)
            ((eq? m 'rear-insert-deque!) rear-insert-deque!)
            ((eq? m 'front-remove-deque!) front-remove-deque!)
            ((eq? m 'rear-remove-deque!) rear-remove-deque!)
            ((eq? m 'print-deque) print-deque)
            (else (error "Unknown method for queue:" m))))
    dispatch))

(define (empty-deque? dq) ((dq 'empty-deque?)))
(define (front-deque dq) ((dq 'front-deque)))
(define (rear-deque dq) ((dq 'rear-deque)))
(define (front-insert-deque! dq item) ((dq 'front-insert-deque!) item))
(define (rear-insert-deque! dq item) ((dq 'rear-insert-deque!) item))
(define (front-remove-deque! dq) ((dq 'front-remove-deque!)))
(define (rear-remove-deque! dq) ((dq 'rear-remove-deque!)))
(define (print-deque dq) ((dq 'print-deque)))

(define (test-deque)
  (define d (make-deque)) (print-deque d)
  (front-insert-deque! d 2) (print-deque d)
  (front-insert-deque! d 1) (print-deque d)
  (rear-insert-deque! d 3) (print-deque d)
  (rear-insert-deque! d 4) (print-deque d)
  (display "empty-deque?: ") (display (empty-deque? d)) (newline)
  (display "front-deque: ") (display (front-deque d)) (newline)
  (display "rear-deque: ") (display (rear-deque d)) (newline)
  (rear-remove-deque! d) (print-deque d)
  (front-remove-deque! d) (print-deque d)
  (rear-remove-deque! d) (print-deque d)
  (front-remove-deque! d) (print-deque d)
  (display "empty-deque?: ") (display (empty-deque? d)) (newline)
  'done)
  